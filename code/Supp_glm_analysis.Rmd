---
title: "Supp_glm_analysis"
author: "Emma M Atkinson, Bruno S Carturan, Clare P Atkinson, Andrew W Bateman, Katrina Connors, Eric Hertz, Stephanie J Peacock"
date: "2025-05-14"
output:
  html_document:
    toc: true                  # Adds a table of contents to the document
    toc_float: true           # Makes the table of contents float on the side as the reader scrolls.
    toc_collapsed: true        # Starts the table of contents in a collapsed state.
    toc_depth: 3               # Specifies the depth of headers (e.g., ##, ###) to include in the table of contents.
    number_sections: true      # 
    theme: journal  # lumen
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r, include=FALSE}
rm(list = ls())
graphics.off()

wd <- gsub("code","",getwd())

wd_figures <- paste0(wd,"figures")
wd_data_input <- paste0(wd,"data_input")
wd_data_output <- paste0(wd,"data_output")

library(tidyr)
library(dplyr)
library(paletteer) # https://r-graph-gallery.com/color-palette-finder
library(readxl)
# library(here)
library(scales)
library(AICcmodavg) # for AICc
library(car)
library(MASS)
library(psych)

source("functions.R")
source("colours.R")

figures_print <- F

#
# Import files

#'* Counts and proportions of populations and CUs assessed across regions and species *
filename <- "populationAssessed_catches_data_remove_0s_NAs"
# filename <- "populationAssessed_catches_data_remove_NAs"

#'* Counts and proportions of populations and CUs assessed per species
data_sp <-  read_xlsx(paste0(wd_data_output,"/",filename,".xlsx"), 
                      sheet = "populations_species") |> as.data.frame()

head(data_sp)

filename <- "populationAssessed_catches_data_remove_NAs"
data_sp_0 <-  read_xlsx(paste0(wd_data_output,"/",filename,".xlsx"), 
                        sheet = "populations_species") |> as.data.frame()

#'* Import the catch data
#' The file is the same regardless of filename
catch  <-  read_xlsx(paste0(wd_data_output,"/",filename,".xlsx"), 
                     sheet = "catches_species_total") |> as.data.frame()
head(catch)

#'* Import the landing value per species per kg *
# https://www.pac.dfo-mpo.gc.ca/analyses-econom-analysis/analyses/econ-perspective-salmon-saumon-eng.html

price_sp <- read.csv(paste0(wd_data_input,"/landed-value-valeur-debarquement-eng.csv"), 
                     header = T)
head(price_sp)
colnames(price_sp)[1] <- "Year"
for(c in 2:ncol(price_sp)){
  price_sp[,c] <- as.numeric(gsub("\\$","",price_sp[,c]))
}
```

```{r, include=FALSE}
#' Create the dataset containing the variables needed.
#' Do that for both datasets with and without the 0s

species <- sort(unique(data_sp$species))

data_sp_l <- list(data_sp,data_sp_0)
names(data_sp_l) <- c("data_sp","data_sp_0")

data_l <- list(NA,NA)
names(data_l) <- c("data","data_0")
i <- 1
for(dataset_selected in data_sp_l){
  year_min <- max(min(dataset_selected$year),min(catch$year),min(price_sp$Year))
  year_max <- min(max(dataset_selected$year),max(catch$year),max(price_sp$Year))
  years <- year_min:year_max
  
  col_selected <- c("species","year","count_pop")
  if(any(grepl("region",colnames(dataset_selected)))){
    col_selected <- c("region","species","year","count_pop")
  }
  
  data <- dataset_selected[dataset_selected$year %in% years,col_selected]
  data$count_catch <- NA
  data$catch_kg <- NA
  data$price_kg <- NA
  for(yr in years){
    # yr <- years[1]
    for(sp in unique(dataset_selected$species)){
      # sp <- unique(dataset_selected$species)[1]
      cond <- catch$species == sp & catch$year == yr
      count_catch <- catch$count[cond]
      catch_kg <- catch$wt_kg[cond]
      
      cond <- price_sp$Year == yr
      price_kg <- price_sp[cond,sp]
      
      cond <- data$species == sp & data$year == yr
      data$count_catch[cond] <- count_catch
      data$catch_kg[cond] <- catch_kg
      data$price_kg[cond] <- price_kg
    }
  }
  
  data$species <- factor(data$species,levels = c("Chinook","Chum","Coho","Pink","Sockeye"))
  
  data_l[[i]] <- data
  i <- i + 1
}
```

The is the Supporting material for the generalized linear regression analysis conducted in: *Atkinson et al. Monitoring for fisheries or for fish? Declines in monitoring of salmon spawners continue despite a conservation crisis*.

# Summary

The goal of the analysis is to quantify the effect of commercial catch on monitoring effort accounting for the effect of price over time and for each species.

We fit two models where the number of populations monitored (`count_pop`) is expressed as (1) a function of landing value, i.e., the product of commercial catch in kg (`catch_kg`) and commercial price per kg (`price_kg`), and (2) as a function of commercial catch alone. For both models we include `species` as a predictor and its interaction with the other predictor. We compare the two models using the Akaike information criterion (AIC).

We selected the negative binomial distribution to correct the overdispersion observed when using the Poisson distribution. The overdispersion is estimated by dividing the residual deviance by the residual degrees of freedom and it is < 1.1 for all four models (two models fitted on two datasets, each reasulting from from filtering or keeping the zeros in NuSEDS, respectively). We assessed collinearity among explanatory variables using pairwise plots and correlation coefficients. We used deviance residuals to verify the models’ assumptions with diagnostic plots (i.e., homoscedasticity of the residuals). We calculated a pseudo-R^2^ as the ratio between the null deviance minus the residual deviance divided by the null deviance.

# The datasets

Dataset containing the number of populations (`count_pop`) extracted from NuSEDS after filtering out the zeros:

```{r, echo=FALSE}
show <- head(data_sp)
rownames(show) <- NULL
show[,c("species","year","count_pop")]
```

Commercial Canadian catch data -- number of fish (`count`) and weight in kg (`wt_kg`) -- downloaded from the [North Pacific Anadromous Fish Commission website](https://www.npafc.org/statistics/) in July 2024:

```{r, echo=FALSE}
cond_sp <- catch$species == "Coho"
show <- head(catch[cond_sp,])
rownames(show) <- NULL
show
```

Price per kg data downloaded from [DFO’s 2023 Economic analysis](https://www.pac.dfo-mpo.gc.ca/analyses-econom-analysis/analyses/econ-perspective-salmon-saumon-eng.html):

```{r, echo=FALSE}
show <- head(price_sp)
rownames(show) <- NULL
show
```

These three datasets are combined into one for the analysis:

```{r, echo=FALSE}
show <- head(data_l$data)
rownames(show) <- NULL
show
```

The data range from `r min(data_l$data$year)` to `r max(data_l$data$year)`.

# Analysis excluding the zeros in NuSEDS

```{r, echo=FALSE, fig.width=8, fig.height=5}
#' Plot the time series on a standardised scale over time
species <- sort(unique(data_sp$species))

data_here <- data_l$data

price_min <- min(data_here$price_kg)
price_max <- max(data_here$price_kg)
catch_min <- min(data_here$catch_kg)
catch_max <- max(data_here$catch_kg)
count_min <- min(data_here$count_pop)
count_max <- max(data_here$count_pop)
year_min <- min(data_here$year)
year_max <- max(data_here$year)

layout(matrix(1:6, nrow = 2, byrow = T), heights = c(1,1.15), widths = c(1.1,1,1))
for(sp in species){
  # sp <- species[1]
  cond_sp <- data_here$species == sp
  count <- (data_here$count_pop[cond_sp] - count_min)/(count_max - count_min)
  catch_kg <- (data_here$catch_kg[cond_sp] - catch_min)/(catch_max - catch_min)
  price <- (data_here$price_kg[cond_sp] - price_min)/(price_max - price_min)
  years <- data_here$year[cond_sp]
  
  side1 <- side2 <- 2
  labels2 <- NA
  xaxt <- "n"
  if(which(sp == species) %in% c(1,4)){
    side2 <- 4.5
    labels2 <- c("min","max")
  }
  if(which(sp == species) %in% 4:5){
    side1 <- 4.5
    xaxt <- "s"
  }
  
  par(mar = c(side1,side2,.5,.5))
  plot(x = years, y = count, xlim = c(year_min,year_max), ylim = c(0,1.1), 
       ylab = "Standardised value", xlab = "Year", yaxt = "n", xaxt = xaxt,
       type = "l", lwd = 2,col = colour_transparency_fun("black",.5))
  axis(side = 2, at = 0:1,labels = labels2)
  if(!which(sp == species) %in% 4:6){
    axis(side = 1, labels = NA)
  }
  lines(x = years, y = price, lwd = 2, col = colour_transparency_fun("#9E163C",.5))
  lines(x = years, y = catch_kg, lwd = 2, col = colour_transparency_fun("#1962A0",.5))
  legend("topleft",sp,bty = "n")
}
plot(x = years, y = rep(1,length(years)), axes = FALSE, xlab = "", ylab = "", col = "white")
axis(side = 3, lwd.ticks = 0, col = "white", line = -.5)
mtext(text = "Year",side = 3, line = -1.3, cex = .7)
legend("center",c("number of populations monitored","catch","price"),
       col = c("black","#1962A0","#9E163C"), lwd = 2, bt = "n")
```

**Figure S1:** Number of populations monitored, catch and price over time for each species. Each variables was normalised across all species to be displayed on the same Y axis. Zeros counts were filtered out in NuSEDS.

## Check for collinearity

We check collinearity using pairwise plots comparing covariates and correlation coefficients:

```{r, echo=FALSE, fig.height=7, fig.width=10}
library(GGally)

ggpairs(data_here,                 # Data frame
        columns = which(colnames(data_here) %in% c("catch_kg","price_kg","species")),       # "count_pop",    # Columns
        aes(color =  species, alpha = 0.5)) +
  theme_bw()
```

**Figure S2:** Pairwise plot showing the distribution, relationship and correlation among the variables.

The correlations among explanatory variables are acceptable.

We notice that the explanatory variables catch (`catch_kg`) and price (`price_kg`) are right skewed, so we transform them with the square root function to improve the model fit:

```{r, echo=FALSE, fig.height=7, fig.width=10}
data_here$catch_kg_sqrt <- sqrt(data_here$catch_kg)
data_here$price_kg_sqrt <- sqrt(data_here$price_kg)

ggpairs(data_here,                 # Data frame
        columns = which(colnames(data_here) %in% c("catch_kg_sqrt","price_kg_sqrt","species")),           # Columns count_pop
        aes(color =  species, alpha = 0.5)) +
  theme_bw()
```

**Figure S3:** Pairwise plot showing the distribution, relationship and correlation among the variables with `catch` and `price` transformed with the square root function.

## Model definition

We first fit a GLM with a Poisson distribution and the log-link function:

```{r}
glm_cps <- glm(count_pop ~ catch_kg_sqrt:price_kg_sqrt * species, 
               data = data_here, family = poisson(link = "log"))

glm_cs <- glm(count_pop ~ catch_kg_sqrt * species, 
              data = data_here, family = poisson(link = "log"))
```

We estimate if there is overdispersion by dividing the residual deviance by the residual degrees of freedom:

```{r}
s_glm_cps <- summary(glm_cps)
round(s_glm_cps$deviance / s_glm_cps$df.residual,2)

s_glm_cs <- summary(glm_cs)
round(s_glm_cs$deviance / s_glm_cs$df.residual,2)
```
The values are much larger than 1, indicating overdispersion.

To solve this issue, we fit the same models but with a negative binomial distribution: 

```{r}
glm_cps <- glm.nb(count_pop ~ catch_kg_sqrt:price_kg_sqrt * species, 
               data = data_here, link = "log")

glm_cs <- glm.nb(count_pop ~ catch_kg_sqrt * species, 
              data = data_here, link = "log")
```

```{r}
s_glm_cps <- summary(glm_cps)
round(s_glm_cps$deviance / s_glm_cps$df.residual,2)

s_glm_cs <- summary(glm_cs)
round(s_glm_cs$deviance / s_glm_cs$df.residual,2)
```

There is no more overdispersion.

## Deviance residuals plots

We check the deviance residuals for `glm_cps`: 

```{r, echo=FALSE,fig.width=10}
span <- .9

glm_selected <- glm_cps

res <- resid(glm_selected, type = "deviance")

layout(matrix(1:6,nrow = 2, byrow = T))
par(mar = c(4.5,4.5,.5,.5))

fit <- predict(glm_selected)
plot(y = res, x = fit, xlab = "Predicted values", ylab = "Deviance residuals")
abline(a = 0,b = 0)
smoothed <- predict(loess(res ~ fit, span = span))
lines(x = fit[order(fit)], y = smoothed[order(fit)], col = "red")

qqnorm(res, main = "")
abline(a = 0, b = 1)

x <- data_here$catch_kg/1000000
plot(y = res, x = x, xlab = "Catch (in megatonne)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
x <- data_here$price_kg
plot(y = res, x = x, xlab = "Value (in CAD per kg)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
boxplot(res ~ data_here$species, xlab = "Species", ylab = "Deviance residuals", horizontal = F)
abline(0,0)
```

**Figure S4:** Residual diagnostic plots for the generalised linear model with a negative binomial distribution and log-link function to predict the number of populations monitored as a function of commercial catches, price and species (n = `r length(res)`).  Zero counts in NuSEDS were removed.

And for `glm_cs`:

```{r, echo=FALSE,fig.width=10}
span <- .9

glm_selected <- glm_cs

res <- resid(glm_selected, type = "deviance")

layout(matrix(1:6,nrow = 2, byrow = T))
par(mar = c(4.5,4.5,.5,.5))

fit <- predict(glm_selected)
plot(y = res, x = fit, xlab = "Predicted values", ylab = "Deviance residuals")
abline(a = 0,b = 0)
smoothed <- predict(loess(res ~ fit, span = span))
lines(x = fit[order(fit)], y = smoothed[order(fit)], col = "red")

qqnorm(res, main = "")
abline(a = 0, b = 1)

x <- data_here$catch_kg/1000000
plot(y = res, x = x, xlab = "Catch (in megatonne)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
x <- data_here$price_kg
plot(y = res, x = x, xlab = "Value (in CAD per kg)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
boxplot(res ~ data_here$species, xlab = "Species", ylab = "Deviance residuals", horizontal = F)
abline(0,0)
```

**Figure S5:** Residual diagnostic plots for the generalised linear model with a negative binomial distribution and log-link function to predict the number of populations monitored as a function of commercial catches and species (n = `r length(res)`).  Zero counts in NuSEDS were removed.

The residuals plots do not invalidate both models.

## Model comparison

We compare the two models using AIC and pseudo-R^2^. The pseudo-R^2^ is expressed as the ratio between the null deviance minus the residual deviance divided by the null deviance.

```{r, echo=FALSE}
show <- data.frame(model = c("glm_cps","glm_cs"))

show$AIC <- lapply(list(glm_cps,glm_cs),function(m){
    return(round(AIC(m),1))
  }) |> unlist()

# show$AICc <- lapply(list(glm_cps,glm_cs),function(m){
#     return(AICc(m))
#   }) |> unlist()

show$R2_pseudo <- lapply(list(glm_cps,glm_cs),function(m){
    sm <- summary(m)
    out <- (sm$null.deviance - sm$deviance)/sm$null.deviance
    return(round(out,3))
  }) |> unlist()

show
```

The model expressing the effect of landed value (i.e,, the product of catch `catch_kg` and price `price_kg`) on the number of population monitored (`glm_cps`) is the best model according to AIC (delta AIC = `r show$AIC[2] - show$AIC[1]`).


## Parameter estimates

The parameter estimates for `glm_cps` are:

```{r, echo=FALSE}
summary_l <- list()
count <- 1
for(sm in list(s_glm_cps,s_glm_cs)){
  sm <- sm[["coefficients"]]
  
  out <- data.frame(parameters = rownames(sm),
                    estimate = round(sm[,"Estimate"],3),
                    SE = round(sm[,"Std. Error"],4),
                    P_value = round(sm[,"Pr(>|z|)"],3))
  
  out$P_value <- sapply(sm[,"Pr(>|z|)"],function(pv){
    out <- "."
    if(pv < 0.001){
      out <- "< 0.001"
    }else if(pv < 0.01){
      out <- "< 0.01"
    }else if(pv < 0.05){
      out <- "< 0.05"
    }else{
      out <- round(pv,2)
    }
    return(out)
  })
  rownames(out) <- NULL
  summary_l[[count]] <- out
  count <- count + 1
}

names(summary_l) <- c("glm_cps","glm_cs")
summary_l$glm_cps
```

The parameter estimates for `glm_cs` are:

```{r,echo=FALSE}
summary_l$glm_cs
```

## Predictions

We predict *number of populations monitored* (`count_pop`) as a function of *Landed value* = *catch* (`catch_kg`)  $\times$ *price* (`price_kg`) for each species using the `glm_cps` model:

```{r, echo=FALSE, fig.height=6, fig.width=9}

suffix <- "WHITOUT_0s"
count <- 1

model_selected <- glm_cps

y_max <- max(data_here$count_pop)
y_min <- min(data_here$count_pop)

colfunc_yr <- colorRampPalette(c("#9E163C","#1962A0"))
col_points <- colour_transparency_fun(colfunc_yr(length(years)),.5)
names(col_points) <- years

if(figures_print){
  jpeg(paste0(wd_figures,"/Predictinon_glm_",suffix,".jpeg"),
       width = 20, height = 15, units = 'cm', res = 300)
}
layout(mat = matrix(1:6, nrow = 2, byrow = T), widths = c(1.22,1,1), heights = c(1,1.07))
for(sp in species){
  # sp <- "Chum"
  
  cond_sp <- data_here$species == sp
  
  data_glm <- data_here[cond_sp,]
  
  data_glm$landing_value <- data_glm$catch_kg * data_glm$price_kg
  data_glm <- data_glm[order(data_glm$landing_value),]
  
  x_max <- max(data_glm$landing_value)
  x_min <- min(data_glm$landing_value)
  
  side1 <- 3
  side2 <- .5
  xlabel <- ylabel <- ""
  yaxt <- "n"
  if(count %in% c(1,4)){
    side2 <- 4.5
    yaxt <- "s"
    ylabel <- "Number of population monitored"
  }
  if(count > 3){
    side1 <- 4.5
    xlabel <- "Landed value (CAD M)"
  }
  
  par(mar = c(side1, side2, .5, .5))
  plot(NA,xlim = c(x_min,x_max),ylim = c(y_min,y_max), xaxt = "n", yaxt = yaxt,
       xlab = xlabel, ylab = ylabel)
  xticks <- axTicks(1)
  axis(side = 1, at = xticks, labels = xticks / 1000000)
  
  # data points
  points(x = data_glm$landing_value,y = data_glm$count_pop, 
         col = col_points[as.character(data_glm$year)], pch = 16 ,cex = 1.5)
  
  legend("topleft",legend = paste0(letters[count],") ",sp), bty = "n")
  
  # legend("bottomleft",paste0("n = ",sum(cond_sp)), bty = "n")
  
  fit_se <- predict(object = model_selected,
                    newdata = data_glm, 
                    type = "response", se.fit = T)
  
  CI_low <- fit_se$fit - 1.96 * fit_se$se.fit
  CI_high <- fit_se$fit + 1.96 * fit_se$se.fit
  
  polygon(x = c(data_glm$landing_value,rev(data_glm$landing_value)), 
          y = c(CI_low,rev(CI_high)), border = NA,
          col = colour_transparency_fun("grey35",alpha = .2))
  
  lines(x = data_glm$landing_value, y = fit_se$fit, 
        col = colour_transparency_fun("grey10",alpha = .7), lwd = 2)
  
  count <- count + 1
}
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(0,4))
yrs_points <- c("1960","1980","2000","2020")
x_points <- c(1,1.7,2.4,3.1)
text(x = 2, y = 1.1, labels = "Years", cex = 1.5)
points(x = x_points, y = rep(1,4), pch = 16, cex = 2, col = col_points[yrs_points])
text(x = x_points, y = rep(.95,4), labels = yrs_points)
if(figures_print){
  dev.off()
}
```

**Figure S6:** Prediction of the number of populations monitored as a function of landed value (in million of CAD), which is the product between commercial catch (in kg) and price (in CAD per kg). A generalised linear model with a negative binomial distribution and log-link function was fitted for each species (n = `r nrow(data_here)`). Lines and polygons represent model fits and 95% confidence intervals, respectively; circles represent the data, which span from `r min(data_here$year)` and `r min(data_here$year)`. Zero counts in NuSEDS were filtered out. This figure is the one appearing in the main text.

# Analysis inclding the zeros in NuSEDS

We use here the equivalent dataset but where zeros were considered as positive observation to assess the number of population monitored in a given year:

```{r, echo=FALSE}
show <- head(data_l$data_0)
rownames(show) <- NULL
show
```

```{r, echo=FALSE, fig.width=8, fig.height=5}
#' Plot the time series on a standardised scale over time

data_here <- data_l$data_0

price_min <- min(data_here$price_kg)
price_max <- max(data_here$price_kg)
catch_min <- min(data_here$catch_kg)
catch_max <- max(data_here$catch_kg)
count_min <- min(data_here$count_pop)
count_max <- max(data_here$count_pop)
year_min <- min(data_here$year)
year_max <- max(data_here$year)

layout(matrix(1:6, nrow = 2, byrow = T), heights = c(1,1.15), widths = c(1.1,1,1))
for(sp in species){
  # sp <- species[1]
  cond_sp <- data_here$species == sp
  count <- (data_here$count_pop[cond_sp] - count_min)/(count_max - count_min)
  catch_kg <- (data_here$catch_kg[cond_sp] - catch_min)/(catch_max - catch_min)
  price <- (data_here$price_kg[cond_sp] - price_min)/(price_max - price_min)
  years <- data_here$year[cond_sp]
  
  side1 <- side2 <- 2
  labels2 <- NA
  xaxt <- "n"
  if(which(sp == species) %in% c(1,4)){
    side2 <- 4.5
    labels2 <- c("min","max")
  }
  if(which(sp == species) %in% 4:5){
    side1 <- 4.5
    xaxt <- "s"
  }
  
  par(mar = c(side1,side2,.5,.5))
  plot(x = years, y = count, xlim = c(year_min,year_max), ylim = c(0,1.1), 
       ylab = "Standardised value", xlab = "Year", yaxt = "n", xaxt = xaxt,
       type = "l", lwd = 2,col = colour_transparency_fun("black",.5))
  axis(side = 2, at = 0:1,labels = labels2)
  if(!which(sp == species) %in% 4:6){
    axis(side = 1, labels = NA)
  }
  
  lines(x = years, y = price, lwd = 2, col = colour_transparency_fun("#9E163C",.5))
  lines(x = years, y = catch_kg, lwd = 2, col = colour_transparency_fun("#1962A0",.5))
  
  # show the counts without 0s
  cond_sp <- data_l$data$species == sp
  count_wo0 <- (data_l$data$count_pop[cond_sp] - count_min)/(count_max - count_min)
  lines(x = years, y = count_wo0, lwd = 2, col = colour_transparency_fun("grey30",.5))
  
  legend("topleft",sp,bty = "n")
}
plot(x = years, y = rep(1,length(years)), axes = FALSE, xlab = "", ylab = "", col = "white")
axis(side = 3, lwd.ticks = 0, col = "white", line = -.5)
mtext(text = "Year",side = 3, line = -1.3, cex = .7)
legend("center",c("nb. populations monitored (with 0s)","nb. populations monitored (without 0s)","catch","price"),
       col = c("black","grey30","#1962A0","#9E163C"), lwd = 2, bt = "n")
```

**Figure S7**: Number of populations monitored, catch and price over time for each species. Each variables was normalised across all species to be displayed on the same Y axis. Zeros counts were not filtered out in NuSEDS (also the figure shows the number).

## Check for collinearity

We check collinearity using pairwise plots comparing covariates and correlation coefficients (after transforming *catch* `catch_kg` and *price* `price_kg` with the square root function):

```{r, echo=FALSE, fig.height=7, fig.width=10}
data_here$catch_kg_sqrt <- sqrt(data_here$catch_kg)
data_here$price_kg_sqrt <- sqrt(data_here$price_kg)

ggpairs(data_here,                 # Data frame
        columns = which(colnames(data_here) %in% c("catch_kg_sqrt","price_kg_sqrt","species")),           # Columns count_pop
        aes(color =  species, alpha = 0.5)) +
  theme_bw()
```

**Figure S8**: Pairwise plot showing the distribution, relationship and correlation among the variables with `catch` and `price` transformed with the square root function.

The correlations among explanatory variables are acceptable.


## Model definition

We first fit a GLM with a Poisson distribution and the log-link function:

```{r}
glm_cps <- glm(count_pop ~ catch_kg_sqrt:price_kg_sqrt * species, 
               data = data_here, family = poisson(link = "log"))

glm_cs <- glm(count_pop ~ catch_kg_sqrt * species, 
              data = data_here, family = poisson(link = "log"))
```

We estimate if there is overdispersion by dividing the residual deviance by the residual degrees of freedom:

```{r}
s_glm_cps <- summary(glm_cps)
round(s_glm_cps$deviance / s_glm_cps$df.residual,2)

s_glm_cs <- summary(glm_cs)
round(s_glm_cs$deviance / s_glm_cs$df.residual,2)
```
The values are much larger than 1, indicating overdispersion.

To solve this issue, we fit the same models but with a negative binomial distribution: 

```{r}
glm_cps <- glm.nb(count_pop ~ catch_kg_sqrt:price_kg_sqrt * species, 
               data = data_here, link = "log")

glm_cs <- glm.nb(count_pop ~ catch_kg_sqrt * species, 
              data = data_here, link = "log")
```

```{r}
s_glm_cps <- summary(glm_cps)
round(s_glm_cps$deviance / s_glm_cps$df.residual,2)

s_glm_cs <- summary(glm_cs)
round(s_glm_cs$deviance / s_glm_cs$df.residual,2)
```

There is no more overdispersion.

## Deviance residuals plots

We check the deviance residuals for `glm_cps`: 

```{r, echo=FALSE, fig.width=10}
span <- .9

glm_selected <- glm_cps

res <- resid(glm_selected, type = "deviance")

layout(matrix(1:6,nrow = 2, byrow = T))
par(mar = c(4.5,4.5,.5,.5))

fit <- predict(glm_selected)
plot(y = res, x = fit, xlab = "Predicted values", ylab = "Deviance residuals")
abline(a = 0,b = 0)
smoothed <- predict(loess(res ~ fit, span = span))
lines(x = fit[order(fit)], y = smoothed[order(fit)], col = "red")

qqnorm(res, main = "")
abline(a = 0, b = 1)

x <- data_here$catch_kg/1000000
plot(y = res, x = x, xlab = "Catch (in megatonne)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
x <- data_here$price_kg
plot(y = res, x = x, xlab = "Value (in CAD per kg)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
boxplot(res ~ data_here$species, xlab = "Species", ylab = "Deviance residuals", horizontal = F)
abline(0,0)
```

**Figure S9:** Residual diagnostic plots for the generalised linear model with a negative binomial distribution and log-link function to predict the number of populations monitored as a function of commercial catches, price and species (n = `r length(res)`).  Zero counts in NuSEDS were kept.

And for `glm_cs`:

```{r, echo=FALSE,fig.width=10}
span <- .9

glm_selected <- glm_cs

res <- resid(glm_selected, type = "deviance")

layout(matrix(1:6,nrow = 2, byrow = T))
par(mar = c(4.5,4.5,.5,.5))

fit <- predict(glm_selected)
plot(y = res, x = fit, xlab = "Predicted values", ylab = "Deviance residuals")
abline(a = 0,b = 0)
smoothed <- predict(loess(res ~ fit, span = span))
lines(x = fit[order(fit)], y = smoothed[order(fit)], col = "red")

qqnorm(res, main = "")
abline(a = 0, b = 1)

x <- data_here$catch_kg/1000000
plot(y = res, x = x, xlab = "Catch (in megatonne)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
x <- data_here$price_kg
plot(y = res, x = x, xlab = "Value (in CAD per kg)", ylab = "Deviance residuals")
abline(0,0)
smoothed <- predict(loess(res ~ x, span = span))
lines(x = x[order(x)], y = smoothed[order(x)], col = "red")

#
boxplot(res ~ data_here$species, xlab = "Species", ylab = "Deviance residuals", horizontal = F)
abline(0,0)
```

**Figure S10:** Residual diagnostic plots for the generalised linear model with a negative binomial distribution and log-link function to predict the number of populations monitored as a function of commercial catches and species (n = `r length(res)`).  Zero counts in NuSEDS were kept.

The residuals plots do not invalidate both models.

## Model comparison

We compare the two models using AIC and pseudo-R^2^. The pseudo-R^2^ is expressed as the ratio between the null deviance minus the residual deviance divided by the null deviance.

```{r, echo=FALSE}
show <- data.frame(model = c("glm_cps","glm_cs"))

show$AIC <- lapply(list(glm_cps,glm_cs),function(m){
    return(round(AIC(m),1))
  }) |> unlist()

# show$AICc <- lapply(list(glm_cps,glm_cs),function(m){
#     return(AICc(m))
#   }) |> unlist()

show$R2_pseudo <- lapply(list(glm_cps,glm_cs),function(m){
    sm <- summary(m)
    out <- (sm$null.deviance - sm$deviance)/sm$null.deviance
    return(round(out,3))
  }) |> unlist()

show
```

The model expressing the effect of landed value (i.e,, the product of catch `catch_kg` and price `price_kg`) on the number of population monitored (`glm_cps`) is the best model according to AIC (delta AIC = `r show$AIC[2] - show$AIC[1]`).


## Parameter estimates

The parameter estimates for `glm_cps` are:

```{r, echo=FALSE}
summary_l <- list()
count <- 1
for(sm in list(s_glm_cps,s_glm_cs)){
  sm <- sm[["coefficients"]]
  
  out <- data.frame(parameters = rownames(sm),
                    estimate = round(sm[,"Estimate"],3),
                    SE = round(sm[,"Std. Error"],4),
                    P_value = round(sm[,"Pr(>|z|)"],3))
  
  out$P_value <- sapply(sm[,"Pr(>|z|)"],function(pv){
    out <- "."
    if(pv < 0.001){
      out <- "< 0.001"
    }else if(pv < 0.01){
      out <- "< 0.01"
    }else if(pv < 0.05){
      out <- "< 0.05"
    }else{
      out <- round(pv,2)
    }
    return(out)
  })
  rownames(out) <- NULL
  summary_l[[count]] <- out
  count <- count + 1
}

names(summary_l) <- c("glm_cps","glm_cs")
summary_l$glm_cps
```

The parameter estimates for `glm_cs` are:

```{r,echo=FALSE}
summary_l$glm_cs
```

## Predictions

We predict *number of populations monitored* (`count_pop`) as a function of *Landed value* = *catch* (`catch_kg`)  $\times$ *price* (`price_kg`) for each species using the `glm_cps` model:

```{r, echo=FALSE, fig.height=6, fig.width=9}

suffix <- "WHITH_0s" # not used here
count <- 1

model_selected <- glm_cps

y_max <- max(data_here$count_pop)
y_min <- min(data_here$count_pop)

colfunc_yr <- colorRampPalette(c("#9E163C","#1962A0"))
col_points <- colour_transparency_fun(colfunc_yr(length(years)),.5)
names(col_points) <- years

if(figures_print){
  jpeg(paste0(wd_figures,"/Predictinon_glm_",suffix,".jpeg"),
       width = 20, height = 15, units = 'cm', res = 300)
}
layout(mat = matrix(1:6, nrow = 2, byrow = T), widths = c(1.22,1,1), heights = c(1,1.07))
for(sp in species){
  # sp <- "Chum"
  
  cond_sp <- data_here$species == sp
  
  data_glm <- data_here[cond_sp,]
  
  data_glm$landing_value <- data_glm$catch_kg * data_glm$price_kg
  data_glm <- data_glm[order(data_glm$landing_value),]
  
  x_max <- max(data_glm$landing_value)
  x_min <- min(data_glm$landing_value)
  
  side1 <- 3
  side2 <- .5
  xlabel <- ylabel <- ""
  yaxt <- "n"
  if(count %in% c(1,4)){
    side2 <- 4.5
    yaxt <- "s"
    ylabel <- "Number of population monitored"
  }
  if(count > 3){
    side1 <- 4.5
    xlabel <- "Landed value (CAD M)"
  }
  
  par(mar = c(side1, side2, .5, .5))
  plot(NA,xlim = c(x_min,x_max),ylim = c(y_min,y_max), xaxt = "n", yaxt = yaxt,
       xlab = xlabel, ylab = ylabel)
  xticks <- axTicks(1)
  axis(side = 1, at = xticks, labels = xticks / 1000000)
  
  # data points
  points(x = data_glm$landing_value,y = data_glm$count_pop, 
         col = col_points[as.character(data_glm$year)], pch = 16 ,cex = 1.5)
  
  legend("topleft",legend = paste0(letters[count],") ",sp), bty = "n")
  
  # legend("bottomleft",paste0("n = ",sum(cond_sp)), bty = "n")
  
  fit_se <- predict(object = model_selected,
                    newdata = data_glm, 
                    type = "response", se.fit = T)
  
  CI_low <- fit_se$fit - 1.96 * fit_se$se.fit
  CI_high <- fit_se$fit + 1.96 * fit_se$se.fit
  
  polygon(x = c(data_glm$landing_value,rev(data_glm$landing_value)), 
          y = c(CI_low,rev(CI_high)), border = NA,
          col = colour_transparency_fun("grey35",alpha = .2))
  
  lines(x = data_glm$landing_value, y = fit_se$fit, 
        col = colour_transparency_fun("grey10",alpha = .7), lwd = 2)
  
  count <- count + 1
}
plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", xlim = c(0,4))
yrs_points <- c("1960","1980","2000","2020")
x_points <- c(1,1.7,2.4,3.1)
text(x = 2, y = 1.1, labels = "Years", cex = 1.5)
points(x = x_points, y = rep(1,4), pch = 16, cex = 2, col = col_points[yrs_points])
text(x = x_points, y = rep(.95,4), labels = yrs_points)
if(figures_print){
  dev.off()
}
```

**Figure S11:** Prediction of the number of populations monitored as a function of landed value (in million of CAD), which is the product between commercial catch (in kg) and price (in CAD per kg). A generalised linear model with a negative binomial distribution and log-link function was fitted for each species (n = `r nrow(data_here)`). Lines and polygons represent model fits and 95% confidence intervals, respectively; circles represent the data, which span from `r min(data_here$year)` and `r min(data_here$year)`. Zero counts in NuSEDS were kept.


